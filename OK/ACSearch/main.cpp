#include <iostream>
#include <string.h>
#include "ACSearch.hpp"

using namespace std;
/******************************
多模匹配算法
字典树==>Trie树（单词查找树，哈希树的变种）
统计和排序大量的字符串（搜索引擎==>文本词频统计）
确定性有限状态自动机(DFA)和非确定性有限状态自动机NFA
普通的自动机不能进行多模式匹配，AC自动机增加了失败转移
使用Aho-Corasick算法需要三步：
 1.建立模式的Trie
 2.给Trie添加失败路径
 3.根据AC自动机，搜索待处理的文本
*******************************/
/*******************************************
建立多模式集合的Trie树（自动机）
多模式集合{"say","she","shr","he","her"}对应的Trie树是(#是接受状态)：
       root
     s      h
   a   h      e#
 y#  e#  r#     r#
********************************************/
/*******************************************
为多模式集合的Trie树添加失败路径，建立AC自动机
设这个节点上的字母为C，沿着他父亲的失败指针走
直到走到一个节点，他的儿子中也有字母为C的节点
然后把当前节点的失败指针指向那个字母也为C的儿子
如果一直走到了root都没找到，那就把失败指针指向root
使用广度优先搜索BFS，层次遍历节点来处理，每一个节点的失败路径
************************************************/
/************************************************
从root节点开始，每次根据读入的字符沿着自动机向下移动
当读入的字符，在分支中不存在时，递归走失败路径
如果走失败路径走到了root节点，则跳过该字符，处理下一个字符
因为AC自动机是沿着输入文本的最长后缀移动的，所以在读取完所有输入文本后
最后递归走失败路径，直到到达根节点，这样可以检测出所有的模式
************************************************/
/************************************************
模式串集合：{"nihao","hao","hs","hsr"}
待匹配文本："sdmfhsgnshejfgnihaofhsrnihao"
************************************************/

int main()
{
    char str[] = "sdmfhsgnshejfgnihaofhsrnihao";
    ACSearch *root = ACSearch::buildingTree();
    ACSearch::buildingFailPath(root);
    cout << "String: " << str << endl;
    cout << "locate\t" << "count\t" << "pattern" << endl;
    ACSearch::searchAC(root, str, strlen(str));
    ACSearch::destoryTree(root);
    return 0;
}
